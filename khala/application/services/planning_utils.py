"""Planning Utilities.

Ported from `nano-manus/planner/parser.py`.
Provides parsing logic for step-based plans generated by LLMs.
"""

import re
from typing import Dict, List, Tuple, Optional

CODE_BLOCK_PATTERN = re.compile(r"<tasks>(.*?)</tasks>", re.DOTALL)
TASK_BLOCK_PATTERN = re.compile(r"<subtask>(.*?)</subtask>", re.DOTALL)
# Improved Goal Pattern to be less brittle
GOAL_BLOCK_PATTERN = re.compile(r"^(.*?)(?=<tasks>|$)", re.DOTALL)


def parse_subtask_expression(subtask: str) -> Optional[Dict[str, str]]:
    """Parse a single subtask string like 'res = subtask(agent, "arg")'."""
    # Match pattern: result_name = subtask(agent_id, "task")
    subtask = subtask.strip()

    if "=" not in subtask:
        return None

    # Split by '=' to separate result name and the rest
    parts = subtask.split("=", 1)
    result_name = parts[0].strip()
    expression = parts[1].strip()

    # Extract agent_id and param from subtask(agent_id, "param")
    if not expression.startswith("subtask(") or not expression.endswith(")"):
        return None

    # Get content inside brackets
    inner_content = expression[8:-1]

    # Split by comma, but only first occurrence
    if "," not in inner_content:
        return None

    agent_id, param = [x.strip() for x in inner_content.split(",", 1)]

    # Remove quotes from param if present
    if (param.startswith('"') and param.endswith('"')) or (param.startswith("'") and param.endswith("'")):
        param = param[1:-1]

    # Unescape newlines in param if strictly needed, but Python string handling often handles it.
    # nano-manus didn't explicit unescape, relying on LLM output.

    return {"result_name": result_name, "agent_id": agent_id, "param": param}


def parse_step(step: str) -> Tuple[str, List[Dict[str, str]]]:
    """Parse an LLM response step into a goal and list of subtasks."""
    code_blocks = CODE_BLOCK_PATTERN.findall(step)

    # Try to find goal
    goal_match = GOAL_BLOCK_PATTERN.search(step)
    goal = goal_match.group(1).strip() if goal_match else ""

    if not code_blocks:
        return goal, []

    subtasks_content = code_blocks[0].strip()
    subtask_blocks = TASK_BLOCK_PATTERN.findall(subtasks_content)

    expressions = []
    for st in subtask_blocks:
        parsed = parse_subtask_expression(st.strip())
        if parsed:
            expressions.append(parsed)

    return goal, expressions
